# image.RGBA sync.Pool

Pool `*image.RGBA` allocations with `sync.Pool` to reduce GC pressure in the
tile generation pipeline. Each 256×256 RGBA tile is 256 KB; at high zoom levels
with thousands of tiles, these allocations dominate GC overhead.

## Implementation

- **`internal/tile/rgbapool.go`**: `GetRGBA(w, h)` / `PutRGBA(img)` backed by a
  `sync.Map` of `sync.Pool` instances keyed by `(width, height)`. In practice
  only 1-2 distinct sizes exist per run (e.g. 256×256, 512×512), so the map
  stays tiny. `GetRGBA` zeros the pixel buffer via `clear()` before returning.

- **`newTileData`**: When `detectUniform` or `detectGray` succeeds, the source
  RGBA is no longer stored in the TileData — it's returned to the pool via
  `PutRGBA`. This recycles images immediately when compact representations
  are selected.

- **`TileData.Release()`**: New method that returns the internal `img` to the
  pool and nils the field. Called in `generator.go` after encoding + store,
  since the encoded bytes are what the store keeps — the raw pixels are no
  longer needed.

- **Render path** (`renderTile`, `renderTileTerrarium`): Allocation moved after
  the source-overlap check so empty tiles never allocate. Uses `GetRGBA` and
  returns to pool via `PutRGBA` on early `!hasData` exits.

- **Downsample path** (`downsampleTile`, `downsampleTileTerrarium`): Destination
  image from `GetRGBA`. Temporary child images expanded from gray/uniform
  `TileData` are tracked with a `poolable` flag and returned after the
  downsample loop. Images borrowed from `TileData.img` (direct pointer) are
  not recycled since the TileData still owns them.

- **Deserialize / decode path**: `DeserializeTileData` (RGBA case) and
  `decodeEncoded` (NRGBA→RGBA conversion) use pooled images.

## Files changed

- `internal/tile/rgbapool.go` (new)
- `internal/tile/tiledata.go`
- `internal/tile/resample.go`
- `internal/tile/downsample.go`
- `internal/tile/diskstore.go`
- `internal/tile/generator.go`

## Verification

All existing tests and benchmarks pass. Benchmark allocations for pooled paths
show 0 B/op after pool warm-up in sustained workloads.
